using System.Collections.Concurrent;
using System.Text.RegularExpressions;
using OneWare.Essentials.Helpers;

namespace FEntwumS.NetlistViewer.Services;

public class CcVhdlFileIndexService : ICcVhdlFileIndexService
{
    private static ConcurrentDictionary<UInt64, ConcurrentDictionary<long, long>> _index = new ();
    private static ConcurrentDictionary<UInt64, ConcurrentDictionary<long, string>> _indexToFile = new ();
    
    private ICustomLogger _logger;

    public CcVhdlFileIndexService()
    {
        _logger = ServiceManager.GetCustomLogger();
    }
    
    public async Task<bool> IndexFileAsync(string filePath, ulong netlistId)
    {
        if (!File.Exists(filePath))
        {
            _logger.Log($"File {filePath} does not exist...");
            
            return false;
        }

        ConcurrentDictionary<long, long> fileIndex = new();
        ConcurrentDictionary<long, string> fileIndexToSource = new();
        
        string[] linesToIndex = await File.ReadAllLinesAsync(filePath);

        long currentLine = 1, actualSrcLine = -1;
        string formattedLine = "";

        bool isRelativePath = false;

        foreach (string line in linesToIndex)
        {
            // GHDL stores the corresponding VHDL source file, line and column as a comment preceding the Verilog source
            // line(s). If a line matches the Regex pattern, it is presumed to be a comment. From this comment, the VHDl
            // source file name and line number are extracted and stored
            if (Regex.IsMatch(line, @"\s+\/\*.+\*\/"))
            {
                actualSrcLine = currentLine;

                // Trim whitespace
                formattedLine = line.Trim();
                // Remove block comment (first and last three characters)
                formattedLine = formattedLine.Substring(3, formattedLine.Length - 6);
                
                // Absolute paths are presumed to have a leading / (Linux and OSX) or a single drive letter, followed by
                // a colon (Windows)
                isRelativePath = !(formattedLine.StartsWith('/') || formattedLine.IndexOf(':') == 1);

                // Split the extracted path on colons. The second to last element is the line number, the last element
                // is the column number
                string[] formattedLineSplit = Path.GetFileName(formattedLine).Split(':');

                if (PlatformHelper.Platform is not PlatformId.Wasm or PlatformId.Unknown)
                {
                    formattedLine = Path.Combine(Path.GetDirectoryName(formattedLine)!, formattedLineSplit[0]);
                    
                    // second to last element is the line number
                    // last element is column number (currently unused)
                    actualSrcLine = long.Parse(formattedLineSplit[^2]);
                }
                else
                {
                    return false;
                }

                // VHDL file paths may be relative to the project root directory
                // If this is detected, an absolute path is generated by retrieving the project root directory from the 
                // file path of the cross-compiled Verilog file. This root is then prepended to the relative file path
                if (isRelativePath)
                {
                    var filePathSplit = filePath.Split("build");
                    
                    // Since the separator is preserved, this does not need to use Path.Combine
                    formattedLine = filePathSplit[0] + formattedLine;
                }
                
                fileIndexToSource[currentLine] = formattedLine;
            }
            else
            {
                // Every line that is not a comment is presumed to be from the VHDL source line indicated by the last
                // preceding comment. This may not always be strictly correct, but should at least always point to the
                // correct VHDL source file
                if (actualSrcLine != -1)
                {
                    fileIndex[currentLine] = actualSrcLine;
                    fileIndexToSource[currentLine] = formattedLine;
                }
            }
            
            currentLine++;
        }
        
        _index[netlistId] = fileIndex;
        _indexToFile[netlistId] = fileIndexToSource;

        return true;
    }

    public (string srcfile, long actualSrcline, bool success) GetActualSource(long srcline, ulong netlistId)
    {
        if (!_index.TryGetValue(netlistId, out ConcurrentDictionary<long, long>? fileIndex))
        {
            return ("", 0, false);
        }

        if (!_indexToFile.TryGetValue(netlistId, out ConcurrentDictionary<long, string>? fileIndexToSource))
        {
            return ("", 0, false);
        }

        if (!fileIndex.TryGetValue(srcline, out long actualSrcline))
        {
            return ("", 0, false);
        }

        if (!fileIndexToSource.TryGetValue(srcline, out string? srcfile))
        {
            return ("", 0, false);
        }
        
        return (srcfile, actualSrcline, true);
    }
}
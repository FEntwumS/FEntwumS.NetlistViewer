using System.Collections.Concurrent;
using System.Text.RegularExpressions;
using Microsoft.Extensions.Logging;
using OneWare.Essentials.Helpers;

namespace FEntwumS.NetlistViewer.Services;

public class CcVhdlFileIndexService : ICcVhdlFileIndexService
{
	private static ConcurrentDictionary<UInt64, ConcurrentDictionary<long, long>> _index = new();
	private static ConcurrentDictionary<UInt64, ConcurrentDictionary<long, string>> _indexToFile = new();

	private ILogger _logger;

	public CcVhdlFileIndexService()
	{
		_logger = ServiceManager.GetService<ILogger>();
	}

	public async Task<bool> IndexFileAsync(string filePath, ulong netlistId)
	{
		if (!File.Exists(filePath))
		{
			_logger.LogError($"File {filePath} does not exist...");

			return false;
		}

		ConcurrentDictionary<long, long> fileIndex = new();
		ConcurrentDictionary<long, string> fileIndexToSource = new();

		string[] linesToIndex = await File.ReadAllLinesAsync(filePath);

		long currentLine = 1, actualSrcLine = -1;
		string formattedLine = "";

		bool isRelativePath = false;

		foreach (string line in linesToIndex)
		{
			// GHDL stores the corresponding VHDL source file, line and column as a comment preceding the Verilog source
			// line(s). If a line matches the Regex pattern, it is presumed to be a comment. From this comment, the VHDl
			// source file name and line number are extracted and stored
			if (Regex.IsMatch(line, @"\s+\/\*.+\*\/"))
			{
				actualSrcLine = currentLine;

				// Trim whitespace
				formattedLine = line.Trim();
				// Remove block comment (first and last three characters)
				formattedLine = formattedLine.Substring(3, formattedLine.Length - 6);

				// Absolute paths are presumed to have a leading / (Linux and OSX) or a single drive letter, followed by
				// a colon (Windows)
				isRelativePath = !(formattedLine.StartsWith('/') || formattedLine.IndexOf(':') == 1);

				// Split the extracted path on colons. The second to last element is the line number, the last element
				// is the column number
				string[] formattedLineSplit = Path.GetFileName(formattedLine).Split(':');

				if (PlatformHelper.Platform is not (PlatformId.Wasm or PlatformId.Unknown))
				{
					formattedLine = Path.Combine(Path.GetDirectoryName(formattedLine)!, formattedLineSplit[0]);

					// second to last element is the line number
					// last element is column number (currently unused)
					actualSrcLine = long.Parse(formattedLineSplit[^2]);
				}
				else
				{
					return false;
				}

				// VHDL file paths may be relative to the project root directory
				// If this is detected, an absolute path is generated by retrieving the project root directory from the 
				// file path of the cross-compiled Verilog file. This root is then prepended to the relative file path
				if (isRelativePath)
				{
					var filePathSplit = filePath.Split("build");

					// Since the separator is preserved, this does not need to use Path.Combine
					formattedLine = filePathSplit[0] + formattedLine;
				}

				fileIndexToSource[currentLine] = formattedLine;
			}
			else
			{
				// Every line that is not a comment is presumed to be from the VHDL source line indicated by the last
				// preceding comment. This may not always be strictly correct, but should at least always point to the
				// correct VHDL source file
				if (actualSrcLine != -1)
				{
					fileIndex[currentLine] = actualSrcLine;
					fileIndexToSource[currentLine] = formattedLine;
				}
			}

			currentLine++;
		}

		_index[netlistId] = fileIndex;
		_indexToFile[netlistId] = fileIndexToSource;

		return true;
	}

	public (string srcfile, long actualSrcline, bool success) GetActualSource(long srcline, ulong netlistId)
	{
		if (!_index.TryGetValue(netlistId, out ConcurrentDictionary<long, long>? fileIndex))
		{
			return ("", 0, false);
		}

		if (!_indexToFile.TryGetValue(netlistId, out ConcurrentDictionary<long, string>? fileIndexToSource))
		{
			return ("", 0, false);
		}

		if (!fileIndex.TryGetValue(srcline, out long actualSrcline))
		{
			return ("", 0, false);
		}

		if (!fileIndexToSource.TryGetValue(srcline, out string? srcfile))
		{
			return ("", 0, false);
		}

		return (srcfile, actualSrcline, true);
	}
}